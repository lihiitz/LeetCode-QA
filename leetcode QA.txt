Q
Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). 
n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). 
Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Note: You may not slant the container and n is at least 2.

E.
Input: [1,8,6,2,5,4,8,3,7]
Output: 49

A1.
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
 let max = 0
 
 for (let i = 0; i < height.length; i++){
     for (let j = i + 1; j < height.length; j++){
         let minHeight = Math.min(height[i], height[j])
         let temp = minHeight * (j - i)
         if (temp > max){
             max = temp
         }
     }
 }
    return max
}

TC (Time Complexity) = N^2

A2.
var maxArea = function(height) {
 let max = 0
 
 let l = 0
 let r = height.length - 1
 while(l < r){
     let temp = Math.min(height[l], height[r]) * (r - l)
     if (temp > max){
         max = temp
     }
     if (height[l] < height[r]){
         l++
     }else{
         r--
     }
 }
 return max
}

TC = N


Q
Given an array of integers nums sorted in ascending order, 
find the starting and ending position of a given target value.
Your algorithm's runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].

A.
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */

var searchRange = function(nums, target) {
    let len = nums.length
    let l = 0
    let r = len - 1
    
    if (nums[0] === target && nums[len - 1] === target){//case: 8,8,8,8
        return [0, len -1]
    }
    if (nums[0] === target){//case: 8,8,9,10
        let right = findRightPos(nums, target)
        return [0, right]
    }
    if (nums[len - 1] === target){//case: 6,7,8,8
        let left = findLeftPos(nums, target)
        return [left, len - 1]
    }
    
   //case: 6,7,8,8,9,10 / 6,7,8,9,10 / 6,7,9,10
    let left = findLeftPos(nums, target)
    let right = findRightPos(nums, target)
    return [left, right]
};

let findRightPos = function (nums, target){
    let l = 0
    let r = nums.length - 1
    
    while(l <= r){
        let mid = Math.trunc((l + r) / 2)
        
        if (nums[mid] < target){
            l = mid + 1
        }else if (nums[mid] > target){
            r = mid - 1
        }else{
            if (nums[mid + 1] === target){
                l = mid + 1
            }else{
                return mid
            }
        }
    }
    return -1
}

let findLeftPos = function (nums, target){
    let l = 0
    let r = nums.length - 1
    
    while(l <= r){
        let mid = Math.trunc((l + r) / 2)
        
        if (nums[mid] < target){
            l = mid + 1
        }else if (nums[mid] > target){
            r = mid - 1
        }else{
            if (nums[mid - 1] === target){
                r = mid - 1
            }else{
                return mid
            }
        }
    }
    return -1
}

Q.
Given a sorted array and a target value, 
return the index if the target is found. 
If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Example 1:

Input: [1,3,5,6], 5
Output: 2
Example 2:

Input: [1,3,5,6], 2
Output: 1
Example 3:

Input: [1,3,5,6], 7
Output: 4
Example 4:

Input: [1,3,5,6], 0
Output: 0

A.
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    let len = nums.length
    let l = 0
    let r = len - 1
    
    if (nums[0] > target){
        return 0
    }
    
    if (nums[len - 1] < target){
        return len
    }
    
    while(l <= r){
        let mid = Math.trunc((l + r) / 2)
        
        if (nums[mid] === target){
            return mid
        }
        
        if (nums[mid] > target){
            r = mid - 1
            if (nums[r] < target){
                return mid
            }
            
        }else if (nums[mid] < target){
            l = mid + 1
            if (nums[l] > target){
                return l
            }
        }
    }
};

TC = LOG(N)